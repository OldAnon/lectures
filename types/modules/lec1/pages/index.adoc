= Лекция 1
:stem:

Система типов доказывает отсутствие целого класса нежелательного поведения. 
----
В отличии от тестов, где результат зависит от входных параметров.
----

Это происходит про помощи классификации выражений языка по типам вычисляемых ими значений.

Система типов - это синтаксический метод, т.е. мы не запускаем программу, а лишь смотрим на синтаксис.

Система типов консервативна, т.е. она может не пропускать корректную в runtime программу.

.Применения системы типов:
* Выявление ошибок до запуска программы
* Как инструмент абстракции в коде
* Документация поведения кода
* Безопасность языка, накладывая на абстракции какие-нибудь требования
* Оптимизация кода, зная инварианты конкретных типов

== Бестиповые выражения

Самое простое выражение - логическое выражение

image::bool.png[]



Выражение с натуральными числами

image::num.png[]

[NOTE]
----
succ, pred - часть синтаксиса, а не функции
----

Хотим определять для таких выражений какие-то свойства. Будем использовать рекурсию по структуре выражений.

Например, множество используемых в выражении констант:

image::bool_consts.png[]

image::num_consts.png[]

Или размер:

image::size.png[]

Или глубина:

image::depth.png[]

Индуктивно можно доказывать различные утверждения для этих свойств.

Например:

image::lemma.png[]

Просто для каждого выражения индуктивно доказываем утверждение. 

Тут можно использовать *индукцию по глубине*: +
Если для каждого stem:[s] мы можем доказать, что stem:[P] выполняется для stem:[s], предположив, что stem:[P] выполняется для всех термов stem:[r], таких что stem:[depth(r) < depth(s)], то stem:[P] выполняется для всех stem:[s].

[NOTE]
====
База индукции входит в это определение.
====

Есть также *структурная индукция*, где мы предполагаем выполнимость stem:[P] для всех подтермов терма stem:[s].


---

Мы определили синтаксис выражений, но не определили семантику.

Семантику можно задать в разных стилях:

* Операционная семантика специфицирует поведение языка на основе абстрактной машины для языка.
* Денотационная семантика переводит каждое выражение в математический объект, где мы можем определять какие то свойства кода.
* Аксиоматическая семантика пытается напрямую задать свойства выражениям.

Мы рассматриваем только операционную семантику.

Чтобы ее определить, мы будем описывать процесс вычисления выражений, путем их упрощения.

Из множества термов мы выделяем те, которые считаем значениями. Например, stem:[true] и stem:[false] в логических выражениях:

image::bool_value.png[]

Вот пример вычисления if-then-else:

image::execute.png[]

Сверху черты находятся *предпосылки*, а снизу - *заключения*.

Мы определяли одношаговый переход, но можно легко определить многошаговый переход, если транзитивно-рефлексивно замкнуть одношаговый переход.

Значения чисел:

image::num_values.png[]

Правила вычисления чисел:

image::num_exe.png[]

[NOTE]
====
stem:[v] здесь - это значение (а лучше вообще считать его stem:[nv]).
====

Терм в *нормальной форме*, если к нему не применимо никакое правило вычисления.

Терм *тупиковый*, если он в нормальной форме, но не значение.

== Лямбда исчисление


image::lambda.png[]

Правила вычисления применения:

image::lambda_exe.png[]

Чтобы решить проблему захвата свободной переменной при подстановке, определим множество свободных переменных для терма:

image::free_v.png[]

Ну и собственно сама подстановка:

image::replace.png[]

Если подстановку сделать невозможно, то попробуем заменить именованные захваченные переменные.

Неудобно переименовывать, поэтому существует безымянная нотация, удобная для компьютеров.

Переменная - индекс, обозначающий, сколько лямбд нужно пройти наверх, чтобы дойти до своей:

image::breina.png[]

Правила вычисления:

image::exe_breina.png[]

Как работает сдвиг:

image::move.png[]

Отсечка обозначает, что начиная с нее идут свободные переменные.

