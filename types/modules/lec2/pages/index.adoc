= Лекция 2

== Простые типизированные выражения

Выражение "терм t имеет тип T" интуитивно можно воспринимать, как "терм t вычисляется в значение типа T". Но это не совсем правильно, так как при анализе типов мы не хотим вычислять выражения.

Правила типизации логических выражений:

image::bool_types.png[]

И для чисел:

image::num_types.png[]

Чтобы доказать, что выражение имеет тип T, нужно построить дерево вывода типа:

image::derevo.png[]

Если мы смогли построить дерево вывода типа, то терм *хорошо типизированный*, иначе *плохо типизированный*.


== Простые типы в лямбда исчислении

Проблема возникает сразу с типизацией функций. Для них вводятся новый тип stem:[T_1 -> T_2].

Для функции всегда будем указывать тип аргумента.

Также у нас есть переменные в лямбда исчислении, и они могут быть свободными в выражении. Поэтому в отношение типизации вводится третий параметр: контекст со списком типизаций свободных переменных. 

image::lambda_types.png[]

Проблема возникает с правилом применения: если идти снизу вверх при проверке типов, то появляется неизвестный тип stem:[T_1].

Есть подход, в котором мы попытаемся вычислить тип терма stem:[t_1]. Для этого будем применять правила вывода к типу, поднявшись наверх, а затем будем спускаться вниз, выводя все типы. Так мы получим тип stem:[T_1 -> T_2] для терма stem:[t_1], откуда узнаем stem:[T_1].

== Свойства простого типизированного лямбда исчисления

* Безопасность - если хорошо типизированные термы не могут быть тупиковыми (продвижение) и не могут стать плохо типизируемыми в процессе вычисления (сохранение)

* Продвижение - замкнутый правильно типизированный терм является либо значением, либо его можно одношагово вычислить

* Стирание типов - если стереть в термах информацию о типах, то вычисление таких безтиповых термов будет идентичным типовому. 